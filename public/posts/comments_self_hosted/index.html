<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Comments - Take 3 - On Zola | bytekeeper.org</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="A while ago I added comments for my Jekyll base blog. Since then, I switched to zola.
Its basically a Rust based &ldquo;clone&rdquo; of the static site generator (SSG) Hugo. Compared to Jekyll, it is a lot faster, and I found it to be a lot simpler.
However, Zola has its own set of challenges. For instance, changing themes is nearly impossible and theme extension can get messy. That is the story for a future post.
At some point I might consider creating my own SSG. Building a small one should be easy enough (and due to GitHub&rsquo;s Actions it could be used immediately).">
    <meta name="generator" content="Hugo 0.146.7">
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >




    


    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/posts/comments_self_hosted/">
    

    <meta property="og:url" content="http://localhost:1313/posts/comments_self_hosted/">
  <meta property="og:site_name" content="bytekeeper.org">
  <meta property="og:title" content="Comments - Take 3 - On Zola">
  <meta property="og:description" content="A while ago I added comments for my Jekyll base blog. Since then, I switched to zola. Its basically a Rust based “clone” of the static site generator (SSG) Hugo. Compared to Jekyll, it is a lot faster, and I found it to be a lot simpler. However, Zola has its own set of challenges. For instance, changing themes is nearly impossible and theme extension can get messy. That is the story for a future post. At some point I might consider creating my own SSG. Building a small one should be easy enough (and due to GitHub’s Actions it could be used immediately).">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-11-03T00:00:00+00:00">
    <meta property="article:modified_time" content="2023-11-03T00:00:00+00:00">

  <meta itemprop="name" content="Comments - Take 3 - On Zola">
  <meta itemprop="description" content="A while ago I added comments for my Jekyll base blog. Since then, I switched to zola. Its basically a Rust based “clone” of the static site generator (SSG) Hugo. Compared to Jekyll, it is a lot faster, and I found it to be a lot simpler. However, Zola has its own set of challenges. For instance, changing themes is nearly impossible and theme extension can get messy. That is the story for a future post. At some point I might consider creating my own SSG. Building a small one should be easy enough (and due to GitHub’s Actions it could be used immediately).">
  <meta itemprop="datePublished" content="2023-11-03T00:00:00+00:00">
  <meta itemprop="dateModified" content="2023-11-03T00:00:00+00:00">
  <meta itemprop="wordCount" content="1783">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Comments - Take 3 - On Zola">
  <meta name="twitter:description" content="A while ago I added comments for my Jekyll base blog. Since then, I switched to zola. Its basically a Rust based “clone” of the static site generator (SSG) Hugo. Compared to Jekyll, it is a lot faster, and I found it to be a lot simpler. However, Zola has its own set of challenges. For instance, changing themes is nearly impossible and theme extension can get messy. That is the story for a future post. At some point I might consider creating my own SSG. Building a small one should be easy enough (and due to GitHub’s Actions it could be used immediately).">

	
  </head><body class="ma0 avenir bg-near-white development">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l center items-center justify-between">
    <a href="/" class="f3 fw2 hover-white white-90 dib no-underline">
      
        bytekeeper.org
      
    </a>
    <div class="flex-l items-center">
      

      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  
  <article class="flex-l mw8 center ph3 flex-wrap justify-between">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        List of blog posts
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">Comments - Take 3 - On Zola</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2023-11-03T00:00:00Z">November 3, 2023</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>A <a href="@comments-on-jekyll/index.md">while ago</a> I added comments for my Jekyll base blog. Since then, I switched to <a href="https://www.getzola.org/">zola</a>.
Its basically a Rust based &ldquo;clone&rdquo; of the static site generator (SSG) <a href="https://gohugo.io/">Hugo</a>. Compared to Jekyll, it is a lot faster, and I found it to be a lot simpler.
However, Zola has its own set of challenges. For instance, changing themes is nearly impossible and theme extension can get messy. That is the story for a future post.
At some point I might consider creating my own SSG. Building a small one should be easy enough (and due to GitHub&rsquo;s Actions it could be used immediately).</p>
<p>Why did I move? Jekyll was basically the go-to SSG back when GitHub only supported it. And it always supported an outdated version. And Jekyll is generally pretty slow.
And after some small update I could not get it to run on my machine in a reasonable amount of time (minutes is reasonable here). Searching for a new led me to Hugo, and then in turn to its Rust &ldquo;clone&rdquo; Zola.
I tend to prefer applications written in Rust nowadays, but only slightly - due to the fact that I could contribute code.</p>
<p>Oh and, while migrating, I trashed the comment functionality - oops. Now its time to restore it back to its old (and pretty empty) glory.</p>
<p><a href="@comments-on-jekyll/index.md#step-1-create-a-service-that-accepts-comments">Previously</a> I used CGI. It&rsquo;s a bit archaic and cumbersome.
So here&rsquo;s what we&rsquo;ll do:</p>
<ol>
<li>First, we&rsquo;ll transform it to a web service</li>
<li>We&rsquo;ll switch from our custom (and now obsolete) GitHub client to a working one I don&rsquo;t have to maintain</li>
<li>Our Javascript client needs to be re-added to the new Zola generated site</li>
</ol>
<p>Here&rsquo;s a sequence diagram of how it is supposed to work:
{{ fit_img(path=&ldquo;Sequence Diagram Comments.png&rdquo;, alt=&ldquo;Comment Sequence Diagram&rdquo;) }}</p>
<h1 id="our-own-web-server">Our own Web Server</h1>
<p>Now, first, we need to implement our own TCP stack&hellip; J/k we&rsquo;ll use <a href="https://hyper.rs/">hyper</a>. We could use <a href="https://github.com/tokio-rs/axum/">Axum</a> but we won&rsquo;t be needing any full blown web server anytime soon.</p>
<p>Let&rsquo;s fire up a simple server at <code>127.0.0.0:3000</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> core::convert::Infallible;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> hyper::service::{make_service_fn, service_fn};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> hyper::{Body, Error, Request, Response, Server};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::net::SocketAddr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">/// This is the actual endpoint:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/// It should take a comment from a user by POST request and convert it to instructions on GitHub.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/// The result should be a branch which includes the comment. And a PR for the branch for easy review and merge-ability.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">post_comment_service</span>(_req: <span style="color:#a6e22e">Request</span><span style="color:#f92672">&lt;</span>Body<span style="color:#f92672">&gt;</span>) 
</span></span><span style="display:flex;"><span>        -&gt; Result<span style="color:#f92672">&lt;</span>Response<span style="color:#f92672">&lt;</span>Body<span style="color:#f92672">&gt;</span>, Infallible<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    Ok(Response::new(<span style="color:#e6db74">&#34;Hello World&#34;</span>.into()))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[tokio::main]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() -&gt; Result<span style="color:#f92672">&lt;</span>(), Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> addr <span style="color:#f92672">=</span> SocketAddr::from(([<span style="color:#ae81ff">127</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>], <span style="color:#ae81ff">3000</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> post_comment_service <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>        make_service_fn(<span style="color:#f92672">|</span>_conn<span style="color:#f92672">|</span> <span style="color:#66d9ef">async</span> { 
</span></span><span style="display:flex;"><span>        Ok::<span style="color:#f92672">&lt;</span>_, Infallible<span style="color:#f92672">&gt;</span>(service_fn(post_comment_service))
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> server <span style="color:#f92672">=</span> Server::bind(<span style="color:#f92672">&amp;</span>addr).serve(post_comment_service);
</span></span><span style="display:flex;"><span>    server.<span style="color:#66d9ef">await</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Simple enough.</p>
<h1 id="choosing-a-github-client-for-rust">Choosing a GitHub Client for Rust</h1>
<p>According to <a href="https://docs.github.com/en/rest/overview/libraries-for-the-rest-api?apiVersion=2022-11-28#rust">GitHub</a> - there&rsquo;s no official client for Rust. But there are two third party clients. <a href="https://github.com/octocat-rs/octocat-rs">Octocat</a> seems to be on the decline. I&rsquo;m sorry if I misjudged here, I just compared the activity to the alternative <a href="https://github.com/XAMPPRocky/octocrab">Octocrab</a> which has a lot more &ldquo;everything&rdquo;. A quick check reveals it seems to be able to create branches, commits and PRs - everything we need. So we&rsquo;re using that, just a quick <code>cargo add octocrab</code>.</p>
<h1 id="representing-comment-requests-and-comment-data">Representing Comment Requests and Comment Data</h1>
<p>Most of the post handling code is the same as before, for brevities sake I will only skim through here:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#e6db74">/// This is the request from a client
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#75715e">#[derive(Deserialize, Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Post</span> {
</span></span><span style="display:flex;"><span>    path: String,
</span></span><span style="display:flex;"><span>    message: String,
</span></span><span style="display:flex;"><span>    name: String,
</span></span><span style="display:flex;"><span>    url: String,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">/// This will be serialized into a comment file on GitHub
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#75715e">#[derive(Serialize, Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Comment</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    id: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span>,
</span></span><span style="display:flex;"><span>    message: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span>,
</span></span><span style="display:flex;"><span>    name: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span>,
</span></span><span style="display:flex;"><span>    url: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span>,
</span></span><span style="display:flex;"><span>    date: <span style="color:#66d9ef">u64</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>So, let&rsquo;s modify our <code>post_comment_service</code> to actually do something. First we need to grab ourselves the content and then deserialize it to a <code>Post</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> Ok(post_request) <span style="color:#f92672">=</span> hyper::body::to_bytes(body).<span style="color:#66d9ef">await</span> <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        [<span style="color:#f92672">..</span>.]
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> Ok(post): Result<span style="color:#f92672">&lt;</span>Post, _<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> serde_json::from_slice(<span style="color:#f92672">&amp;*</span>post_request) <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Ok(Response::builder()
</span></span><span style="display:flex;"><span>            .status(StatusCode::<span style="color:#66d9ef">BAD_REQUEST</span>)
</span></span><span style="display:flex;"><span>            .body(<span style="color:#e6db74">&#34;Invalid JSON&#34;</span>.into())
</span></span><span style="display:flex;"><span>            .unwrap());
</span></span><span style="display:flex;"><span>    };
</span></span></code></pre></div><p>Quick note: Using Axum, this would have been a lot shorter.</p>
<p>The next steps:</p>
<ol>
<li>Create a branch</li>
<li>Add the comment to the correct <code>comments.yaml</code> file</li>
<li>Create a pull request</li>
</ol>
<p>Creating a branch requires a commit SHA it is based on, so we grab that and create a branch of it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> master_sha <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> repo
</span></span><span style="display:flex;"><span>        .get_ref(<span style="color:#f92672">&amp;</span>Reference::Branch(<span style="color:#e6db74">&#34;master&#34;</span>.to_string()))
</span></span><span style="display:flex;"><span>        .<span style="color:#66d9ef">await</span>
</span></span><span style="display:flex;"><span>        .expect(<span style="color:#e6db74">&#34;Could not get master ref&#34;</span>)
</span></span><span style="display:flex;"><span>        .object
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Object::Commit { sha, <span style="color:#f92672">..</span> } <span style="color:#f92672">|</span> Object::Tag { sha, <span style="color:#f92672">..</span> } <span style="color:#f92672">=&gt;</span> sha,
</span></span><span style="display:flex;"><span>        _ <span style="color:#f92672">=&gt;</span> unreachable!(),
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    debug!(<span style="color:#e6db74">&#34;Creating branch {} from {}&#34;</span>, branch_name, master_sha);
</span></span><span style="display:flex;"><span>    repo.create_ref(<span style="color:#f92672">&amp;</span>Reference::Branch(branch_name.clone()), master_sha)
</span></span><span style="display:flex;"><span>        .<span style="color:#66d9ef">await</span>
</span></span><span style="display:flex;"><span>        .expect(<span style="color:#e6db74">&#34;Could not create branch&#34;</span>);
</span></span></code></pre></div><p>Now, due to technical limitations (Zola can read a yaml file, but not a set of files) we need to have all comments of a blog in one file. This will be called <code>comments.yaml</code> as stated above.</p>
<p>A new comment should not just overwrite all other comments, so we first need to grab the file if it exists.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> content_items <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> repo.get_content().path(<span style="color:#f92672">&amp;</span>path).send().<span style="color:#66d9ef">await</span> {
</span></span><span style="display:flex;"><span>        Ok(content_items) <span style="color:#f92672">=&gt;</span> content_items,
</span></span><span style="display:flex;"><span>        Err(_) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            info!(<span style="color:#e6db74">&#34;Assuming no comments present yet at {}&#34;</span>, path);
</span></span><span style="display:flex;"><span>            ContentItems { items: Vec::new() }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// There can&#39;t be more than one file with the same name:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    assert!(content_items.items.len() <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> content <span style="color:#f92672">=</span> content_items.items.iter().next();
</span></span></code></pre></div><p>Now lets create or append to the existing comment file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> new_comment <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>        serde_yaml::to_string(<span style="color:#f92672">&amp;</span>[<span style="color:#f92672">&amp;</span>comment]).expect(<span style="color:#e6db74">&#34;Could not convert comment to yaml&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Yes, this name is rubbish 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> author <span style="color:#f92672">=</span> CommitAuthor {
</span></span><span style="display:flex;"><span>        name: <span style="color:#e6db74">&#34;Comment0r&#34;</span>.to_string(),
</span></span><span style="display:flex;"><span>        email: <span style="color:#e6db74">&#34;none@example.com&#34;</span>.to_string(),
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(content) <span style="color:#f92672">=</span> content {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// GitHub API requires the SHA of the old file to update it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">let</span> (<span style="color:#66d9ef">mut</span> content, sha) <span style="color:#f92672">=</span> (content.decoded_content().unwrap(), content.sha.clone());
</span></span><span style="display:flex;"><span>        writeln!(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> content, <span style="color:#e6db74">&#34;{}&#34;</span>, new_comment).expect(<span style="color:#e6db74">&#34;Could not add comment to file&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        repo.update_file(
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&amp;</span>path,
</span></span><span style="display:flex;"><span>            format!(<span style="color:#e6db74">&#34;Added comment from &#39;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#39;&#34;</span>, comment.name),
</span></span><span style="display:flex;"><span>            content,
</span></span><span style="display:flex;"><span>            sha,
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>        .branch(<span style="color:#f92672">&amp;</span>branch_name)
</span></span><span style="display:flex;"><span>        .commiter(author)
</span></span><span style="display:flex;"><span>        .send()
</span></span><span style="display:flex;"><span>        .<span style="color:#66d9ef">await</span>
</span></span><span style="display:flex;"><span>        .expect(<span style="color:#e6db74">&#34;Could not update file&#34;</span>);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        debug!(<span style="color:#e6db74">&#34;Creating new file at {}&#34;</span>, path);
</span></span><span style="display:flex;"><span>        repo.create_file(
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&amp;</span>path,
</span></span><span style="display:flex;"><span>            format!(<span style="color:#e6db74">&#34;Added comment from &#39;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#39;&#34;</span>, comment.name),
</span></span><span style="display:flex;"><span>            new_comment,
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>        .branch(<span style="color:#f92672">&amp;</span>branch_name)
</span></span><span style="display:flex;"><span>        .commiter(author)
</span></span><span style="display:flex;"><span>        .send()
</span></span><span style="display:flex;"><span>        .<span style="color:#66d9ef">await</span>
</span></span><span style="display:flex;"><span>        .expect(<span style="color:#e6db74">&#34;Could not create file&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>I decided against parsing the existing file. It should be fine. If it&rsquo;s not, I can fix it manually, its a <a href="https://yaml.org">YAML</a> file after all.
Instead, just a &ldquo;grab the existing content&rdquo; and &ldquo;append new comment&rdquo; in YAML format, if nothing is there &ldquo;create a new file&rdquo; and &ldquo;write the comment as initial content&rdquo;.</p>
<p>Last but not least, I don&rsquo;t want to manually merge or create pull requests, so let&rsquo;s do that as well:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span>    oc.pulls(<span style="color:#f92672">&amp;</span>config.owner, <span style="color:#f92672">&amp;</span>config.repo)
</span></span><span style="display:flex;"><span>        .create(
</span></span><span style="display:flex;"><span>            format!(<span style="color:#e6db74">&#34;New comment from </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, comment.name),
</span></span><span style="display:flex;"><span>            branch_name,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;master&#34;</span>,
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>        .send()
</span></span><span style="display:flex;"><span>        .<span style="color:#66d9ef">await</span>
</span></span><span style="display:flex;"><span>        .expect(<span style="color:#e6db74">&#34;Could not create PR&#34;</span>);
</span></span></code></pre></div><p>This will create a PR with the title &ldquo;New comment from <!-- raw HTML omitted -->&rdquo; trying to merge the new branch into master.</p>
<p>Now, this service serves no purpose, if no-one ever calls it. That would be&hellip;</p>
<h1 id="the-client-part">The Client Part</h1>
<p>I&rsquo;ll omit the html part for now, it&rsquo;s mostly a boring form with a name, an URL and a message field - and a submit button.
The &ldquo;interesting&rdquo; part is the JavaScript client, that will do the following:</p>
<ol>
<li>Take the comment</li>
<li>Send it to an endpoint</li>
<li>Show the user a success or error page</li>
</ol>
<p>Here is the first part:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-JavaScript" data-lang="JavaScript"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">form</span> <span style="color:#f92672">=</span> document.<span style="color:#a6e22e">getElementById</span>(<span style="color:#e6db74">&#39;commentForm&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">form</span>.<span style="color:#a6e22e">addEventListener</span>(<span style="color:#e6db74">&#39;submit&#39;</span>, <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">event</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Don&#39;t submit actually
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">preventDefault</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">formData</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">FormData</span>(<span style="color:#a6e22e">form</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">commentData</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">formData</span>.<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#39;name&#39;</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">url</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">formData</span>.<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#39;url&#39;</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">message</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">formData</span>.<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#39;message&#39;</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">path</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;{{ current_path | safe }}&#39;</span>,
</span></span><span style="display:flex;"><span>    };
</span></span></code></pre></div><p>Don&rsquo;t get confused by the <code>{{ ... }}</code> stuff, that&rsquo;s part of the template engine Zola uses (<a href="https://keats.github.io/tera/">Tera</a>).</p>
<p>With the data firm in our grasp, onwards to step 2:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-JavaScript" data-lang="JavaScript"><span style="display:flex;"><span><span style="color:#75715e">// Now post the comment to the service
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">fetch</span>(<span style="color:#e6db74">&#39;{{ config.extra.api_url | safe }}/comment&#39;</span>, {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">method</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;POST&#39;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">headers</span><span style="color:#f92672">:</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;Content-Type&#39;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;application/json&#39;</span>
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">body</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">stringify</span>(<span style="color:#a6e22e">commentData</span>)
</span></span></code></pre></div><p>And finally step 3:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-JavaScript" data-lang="JavaScript"><span style="display:flex;"><span>}).<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">response</span> =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">response</span>.<span style="color:#a6e22e">ok</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">form</span>.<span style="color:#a6e22e">reset</span>();
</span></span><span style="display:flex;"><span>        window.<span style="color:#a6e22e">location</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/pages/submitted&#34;</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        window.<span style="color:#a6e22e">location</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/pages/submission-failed&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}).<span style="color:#66d9ef">catch</span>(<span style="color:#a6e22e">error</span> =&gt; {
</span></span><span style="display:flex;"><span>    window.<span style="color:#a6e22e">location</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/pages/submission-failed&#34;</span>;
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><p>I also clear the form when the submit succeeded. Otherwise, returning to the page would keep the form content. On error, I let the content stay, maybe it was just a hiccup after all?</p>
<h1 id="security">Security</h1>
<p>The service itself is pretty small. Due to Rust&rsquo;s nature, I consider buffer under/overflow attacks to be pretty unlikely. Not impossible mind you.
Rust could have some memory safety bug. Hyper uses some <code>unsafe</code> and could have a bug there. Same with <a href="https://github.com/tower-rs/tower">tower</a> which I will use below.
I pass much of the user entered data to Octocrab, which in turn relies on other libraries and interacts with GitHubs API. I expect their API to refuse any malformed requests, otherwise its their problem (unless..).</p>
<h2 id="threat-model">Threat Model</h2>
<p>The service will run on a trusted machine (due to access to a personal access token from GitHub). It is meant to run behind a reverse proxy, but should also work as a public service.
It will not guarantee to work under a DOS attack, but it will guarantee not to let an remote attacker DOS the whole host system.</p>
<p>The main DOS vectors against the host system are:</p>
<ul>
<li>Sending large chunks of data in a post request which would then be sent to GitHub (clogging up up- and downstream)</li>
<li>Sending many small requests which would result in a multiple of API calls to GitHub</li>
</ul>
<h2 id="changes-required-by-the-threat-model">Changes Required by the Threat Model</h2>
<p>First, lets limit the input our services receives to have some basic DOS protection:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> body <span style="color:#f92672">=</span> Limited::new(req.into_body(), <span style="color:#ae81ff">100</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1024</span>);
</span></span></code></pre></div><p>Let&rsquo;s also do some basic rate limiting:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> post_comment_service <span style="color:#f92672">=</span> make_service_fn(<span style="color:#f92672">|</span>_conn<span style="color:#f92672">|</span> <span style="color:#66d9ef">async</span> {
</span></span><span style="display:flex;"><span>        Ok::<span style="color:#f92672">&lt;</span>_, Infallible<span style="color:#f92672">&gt;</span>(RateLimit::new(
</span></span><span style="display:flex;"><span>            service_fn(post_comment_service),
</span></span><span style="display:flex;"><span>            Rate::new(<span style="color:#ae81ff">1</span>, Duration::from_secs(<span style="color:#ae81ff">10</span>)),
</span></span><span style="display:flex;"><span>        ))
</span></span><span style="display:flex;"><span>    });
</span></span></code></pre></div><p>It would certainly be better to limit per IP. But the intention here was not to prevent DOS attacks to the service itself, just the host system.</p>
<h1 id="whats-next">What&rsquo;s Next?</h1>
<p>Obviously, the code could be improved - it was basically almost completely rewritten in about 2 days. This will have to wait for another time&hellip;</p>
<h1 id="conclusion">Conclusion</h1>
<p>It was a fun and sometimes tedious exercise. Hyper&rsquo;s API is &ldquo;strange&rdquo; - services return a <code>Result&lt;.., Infallible&gt;</code>. Why not just the real result. I guess I could read up on the reason, but its certainly hidden very well.
Octocrab is pretty decent. It&rsquo;s a bit cumbersome at times (i.e. <code>send()</code> for API that retrieves things). Authenication is really annoying and lacks documentation - but is easy enough once figured out.
I ran into an issue where I configured the wrong URL to access GitHub - I swear I saw it somewhere in the Octocrab repository.
This was made even worse by the API suddenly trying to deserialize incomplete JSON objects from GitHub (like cut off after 21 characters, without any reason why).</p>
<p>It took a fair bit longer than expected.</p>
<p>The parts I did not present:</p>
<ul>
<li>The cloudflare config to route the <code>api</code> sub-domain to my VPS</li>
<li>My VPS&rsquo; Apache2 config for a secure reverse proxy</li>
<li>Getting a signed certificate</li>
</ul>
<p>I hope you enjoyed this post of mine, feel free to comment. It should work now. If not, I&rsquo;ll just assume you&rsquo;re happy and live in blissful ignorance.</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href="http://localhost:1313/" >
    &copy;  bytekeeper.org 2025 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
