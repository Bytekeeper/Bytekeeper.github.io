<!DOCTYPE html>
<html lang="en">
    <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta http-equiv="content-type" content="text/html; charset=utf-8">

      <!-- Enable responsiveness on mobile devices-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

      <title>Remnants of the Vanquished - </title>

      
        
          <link rel="alternate" type="application/rss+xml" title="RSS" href="https://www.bytekeeper.org/rss.xml">
        
      


      
          <link rel="stylesheet" href="https://www.bytekeeper.org/site.css">
          
      

      
<link rel="stylesheet" href="https://www.bytekeeper.org/custom.css">
<script defer data-domain="bytekeeper.org" src="https://plausible.bytekeeper.org/js/pls.js"></script>
<meta name="referrer" content="same-origin">

    </head>

    <body class="hack dark main container">
        
    
        
                
                    <header>
                        <nav itemscope itemtype="http://schema.org/SiteNavigationElement">
                        
                            <a itemprop="url"
                               class=""
                               href="https:&#x2F;&#x2F;www.bytekeeper.org&#x2F;tags">
                                <span itemprop="name">Tags
                                </span></a>
                        
                            <a itemprop="url"
                               class=""
                               href="https:&#x2F;&#x2F;www.bytekeeper.org&#x2F;rss.xml">
                                <span itemprop="name">RSS Feed
                                </span></a>
                        
                        </nav>
                    </header>
                
            
    

<article itemscope itemtype="http://schema.org/BlogPosting">
    <header>
        <h1 itemprop="headline">Remnants of the Vanquished</h1>
        <span class="muted">
    <div>
    <svg class="icon i-clock" viewBox="0 0 32 32"
         width="16" height="16" fill="none" stroke="currentcolor"
         stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
        <circle cx="16" cy="16" r="14"/>
        <path d="M16 8 L16 16 20 20"/>
    </svg>
    <span>5 minute read</span>
    <svg class="icon i-edit" viewBox="0 0 32 32"
         width="16" height="16" fill="none" stroke="currentcolor"
         stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
        <path d="M30 7 L25 2 5 22 3 29 10 27 Z M21 6 L26 11 Z M5 22 L10 27 Z"/>
    </svg>

    Published: 2023-12-19
    </div>

    
        
            <a class="tagmeta" href="https://www.bytekeeper.org/tags/gamedev/">gamedev</a> 
        
    
</span>
    </header>
    <div itemprop="articleBody">
      <p>Now, let me reveal the name of the <a href="https://www.bytekeeper.org/unnamed-game-2/">Unnamed Game</a>. This time, we will focus on some more technical aspects of the game. As a disclaimer: I use Bevy, which more or less enforces the use of an Entity Component System (ECS). ECS is kind of a hype (micro-services anyone?), of course it can be used for everything - but does it fit everything? Still, I am not yet turning my back on Bevy just yet, so I'll have to make do.</p>
<h2 id="short-recap"><a class="zola-anchor" href="#short-recap" aria-label="Anchor link for: short-recap">ðŸ”—</a>Short Recap</h2>
<p><a href="https://www.bytekeeper.org/unnamed-game-2/#ecs-systems">Last time</a> I was babbling about model and visual components. I laid out some rules I "found" for turn based games using ECS:</p>
<ul>
<li>Only core game logic systems may modify game logic components.</li>
<li>Only core game logic systems may remove game logic entities. They should send events in that case.</li>
<li>Non core game logic systems may add and modify their components to game logic entities. They must also ensure to clean up after themselves by removing components when systems go out of scope.</li>
<li>Non core game logic systems must handle entities suddenly disappearing and appearing.</li>
</ul>
<p>Alas, while I still think those are valid - a more restrictive approach might be necessary. Let's take a step back and re-evaluate the current design approach.</p>
<h1 id="different-representation-of-what-the-player-sees-and-what-the-game-thinks"><a class="zola-anchor" href="#different-representation-of-what-the-player-sees-and-what-the-game-thinks" aria-label="Anchor link for: different-representation-of-what-the-player-sees-and-what-the-game-thinks">ðŸ”—</a>Different Representation of What the Player Sees and What the Game "Thinks"</h1>
<p>I mentioned <a href="https://www.bytekeeper.org/unnamed-game-2/#how-to-design-entities-and-systems-for-a-turn-based-game">before</a>, that its harder for turn-based game to work with entities. ECS' are designed to run continuously, so for "discrete" components (discrete in time) - the result is stuttering.</p>
<p>But what does that mean? Let's dive into the problem, by looking at several approaches on how to model game entities. For the sake of understandability, we'll limit ourselves to one discrete event: A ship getting destroyed.</p>
<h2 id="visual-components-and-model-components-share-entity"><a class="zola-anchor" href="#visual-components-and-model-components-share-entity" aria-label="Anchor link for: visual-components-and-model-components-share-entity">ðŸ”—</a>Visual Components and Model Components Share Entity</h2>
<p>In this scenario, what the game "thinks" and what the player sees are the same. For the most part. Sounds simple enough. But, it has some repercussions.</p>
<h3 id="immediate-model-updates-a-no-go"><a class="zola-anchor" href="#immediate-model-updates-a-no-go" aria-label="Anchor link for: immediate-model-updates-a-no-go">ðŸ”—</a>Immediate Model Updates: A No-Go</h3>

<img src="shared_entities_immediate_model.png" style="width: 100%" />

<p>To the left is a representative entity. It contains hit points as a model component and a sprite as a visual component. The entity is in the process of being destroyed. To the right is the game state, separated by UI (visuals) and Model (what the game thinks). The UI is red, because the entity suddenly disappears which is inconsistent with what the player expects to happen (things going boooom). But the model is consistent (in a more computer sciency term - all invariants are held).</p>
<p><strong>Conclusion</strong>: This is essentially a bad option, the game is for the player - not for the CPU or my peace of mind.</p>
<h3 id="delayed-model-updates-so-so"><a class="zola-anchor" href="#delayed-model-updates-so-so" aria-label="Anchor link for: delayed-model-updates-so-so">ðŸ”—</a>Delayed Model Updates: So-So</h3>

<img src="shared_entities_delayed_model.png" style="width: 100%" />

<p>A similar representation as before, but this time the entity is not destroyed immediately. Instead, the "planned" destruction is communicated by an event or a flag in some component.</p>
<p>The UI has plenty of time to show explosions and whatnot. But, as indicated by the red model state, there's a period where the model's invariants don't hold: a "dead" ship shouldn't be present anymore. They will have to be removed later, by game model systems mind you, if the non-game-logic systems start meddling around things will get messy).</p>
<p>This will obviously work, but is a bit "ugly" from a technical point of view. The game logic systems will have to "mark" things other game logic systems will "later" do. In-between the game model is in a meh state. If, for example, the player was to leave the game (saving it in the process), loading it later would start by playing some animation - or not. It depends on whether the UI systems recreate the UI components for the already "marked as dead" ship.</p>
<p><strong>Conclusion</strong>: This approach works but carry the stench of potential problems when restoring the game state.</p>
<h2 id="separate-entities-good-but-more-effort"><a class="zola-anchor" href="#separate-entities-good-but-more-effort" aria-label="Anchor link for: separate-entities-good-but-more-effort">ðŸ”—</a>Separate Entities: Good, but More Effort</h2>

<img src="separate_entities.png" style="width: 100%" />

<p>With this design, there are no "reds". There is an entity for the model and an entity for the UI. The UI will try to keep entities in sync. If an entity in the model is destroyed, the UI can keep its entity around and start the destruction animation.</p>
<p>The model's invariants are held, and the player won't be confused. But we pay a price, we need to sync the relevant data. However, it offers the choice to diverge more freely from ECS in the model. The core game model does not need to be based on ECS at all.</p>
<p><strong>Conclusion</strong>: This will work, but will also be more effort to implement.</p>
<h2 id="summary"><a class="zola-anchor" href="#summary" aria-label="Anchor link for: summary">ðŸ”—</a>Summary</h2>
<p>As always, there is no single best solution - all have draw-backs. Coming from a business development perspective, it often pays to separate domain models:</p>

<img src="domain_models.png" style="width: 100%" />

<p>"Sourcing" is the term for where data is coming from. Basically, that is, what I will be doing. That means "Separate Entities" is the way to go from here.</p>
<p>It also means I do not have to use ECS for the core game. Which means I can use a separate package (crate in Rust terms). That means Bevy will "just" be the frontend - which I could replace without touching the game rules at all.</p>
<h1 id="conclusion"><a class="zola-anchor" href="#conclusion" aria-label="Anchor link for: conclusion">ðŸ”—</a>Conclusion</h1>
<p>Having designed and implemented multiple smaller games using ECS, there is a challenge in using it for turn-based games. Using a separate <code>World</code> and schedule is something that can be used to make it work. But the gains are small in my opinion. As shown above I faced basic problems with my approach. I want to avoid wasting time later on, trying to synchronize all the data for entities that are a mixed bag of real-time components and turn-based components.</p>
<p>Thanks for sticking around, maybe you learned something - I sure did. See you next time...</p>

    </div>

    
        <footer>
            <hr>
            <p>
                
                
                
                    and tagged
                    
                        <a href="https://www.bytekeeper.org/tags/gamedev/">gamedev</a>
                        
                    
                
            </p>
            


<div id="comments">


  <h3>Add Comment</h3>
  <form id="commentForm">
       <div>
        <label for="name">Name</label>
       </div>
       <div>
        <input type="text" id="name" name="name" required><br><br>
       </div>

       <div>
        <label for="url">URL</label>
       </div>
       <div>
        <input type="text" id="url" name="url"><br><br>
       </div>

       <div>
        <label for="message">Message</label>
       </div>
       <div>
        <textarea id="message" name="message" required></textarea><br><br>
       </div>

        <!-- Submit button -->
        <input type="submit" value="Submit Comment">
    </form>
    <script>
        const form = document.getElementById('commentForm');

        form.addEventListener('submit', function (event) {
            // Don't submit actually
            event.preventDefault();

            const formData = new FormData(form);

            const commentData = {
                name: formData.get('name'),
                url: formData.get('url'),
                message: formData.get('message'),
                path: '/rotv/',
            };

            // Now post the comment to the service
            fetch('https://api.bytekeeper.org/comment', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(commentData)
            }).then(response => {
                if (response.ok) {
                    form.reset();
                    window.location = "/pages/submitted";
                } else {
                    window.location = "/pages/submission-failed";
                }
            }).catch(error => {
                window.location = "/pages/submission-failed";
            });
        });
    </script>
</div>




        </footer>
    
</article>


    </body>

</html>
